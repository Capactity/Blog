

## 事件循环

> `Event Loop`即事件循环。是指浏览器或`Node`的一种解决`Javascript`单线程运行时不会阻塞的一种机制，即我们经常使用异步的原理，具体分为宏任务和微任务。

**宏任务（MacroTask）:**  `setTimeout`、`setInterval`、`requestAnimationFrame`、**Ajax**、**fetch**、`script 标签代码`、`I/O操作`、`UI渲染`等。

**微任务（MicroTask）:**  `Promise.then`、`MutationObserver`、`Object.observe`。

在浏览器环境下，当某个宏任务执行完后，会查看是否有微任务队列，如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，会依次加入微任务队列。当栈空后，再此读取微任务队列里的任务，依次类推。

> 浏览器环境下，微任务的任务队列是每个宏任务执行完之后执行。在执行微任务时，如果又产生了微任务，会还是放在本次任务执行队列中去执行。

> 在node中，微任务会在时间循环的各个阶段之间执行，执行完一个宏任务后，执行“一定数量”的微任务。具体数量根据`I/O`回调决定。

## 协商缓存和强缓存

协商缓存和强缓存是HTTP中常用的两种缓存机制，它们都可以优化网站性能和减少网络请求。不过二者的实现方式略有不同。

强缓存：当浏览器发起第一次请求时，服务器会在返回响应头中添加Expires或Cache-Control字段来标识该资源的过期时间（即缓存时间），客户端再次请求该资源时，如果当前时间还在缓存时间内，则直接从浏览器缓存中返回，不会再向服务器发送请求。如果已经过了缓存时间，浏览器会把缓存数据标记为过期，并向服务器发送请求获取最新数据。Expires是HTTP/1.0的规范，而Cache-Control则是HTTP/1.1的规范。

协商缓存：当浏览器发起请求时，服务器返回响应头中的ETag或Last-Modified字段来标识该资源的唯一标识和最后修改时间，客户端再次请求该资源时会带上If-None-Match和If-Modified-Since字段携带之前获取到的数据并告诉服务器“我想要的是xx版本的数据”以便服务器判断是否需要重新向客户端返回更新的数据。

由于协商缓存需要与服务端进行交互，所以相对于强缓存，协商缓存会增加一定的延迟，但协商缓存可以更加精确地控制数据的更新和缓存时间。而强缓存虽然简单，但无法保证数据的实时性。

## cookie

1. 如何设置和获取 cookie？

答：可以使用 JavaScript 中的 document.cookie 属性来设置和获取 cookie。

1. 如何使用 cookie 实现自动登录？

答：可以在用户登录成功后，将其身份认证信息保存到 cookie 中。然后，在下次用户访问网站时，应用程序可以读取该 cookie 并根据其中的身份认证信息自动完成登录流程。

1. 如何防止 CSRF 攻击？

答：可以通过在 cookie 中添加 SameSite 属性，限制 cookie 只能在同源请求中发送，从而防止跨站点请求伪造攻击。另外，还可以使用 token 或验证码等技术来增加安全性。

1. 如何使用 cookie 实现多语言切换？

答：可以在用户选择语言后，将其设置保存到 cookie 中。然后，在页面加载时，应用程序可以读取该 cookie 并根据其中的语言设置来显示相应的文本内容。这样就可以实现基于 cookie 的多语言切换功能。

在默认的情况下，Cookie 是不支持跨域的

当然，在某些特殊情况下，我们可以通过一些手段来实现跨域 Cookie 的传递，例如：

1. CORS（跨域资源共享）：设置 Access-Control-Allow-Credentials 和 Access-Control-Allow-Origin 响应头，允许跨域请求访问受信任的域，并在客户端设置 withCredentials 属性为 true，以启用 XMLHttpRequest 发送 Cookie。
2. JSONP（跨域 JSONP 请求）：利用 script 标签和回调函数实现跨域数据传输。但是注意，JSONP 只适用于 GET 请求，且不支持 POST 等其他请求方法。
3. 代理服务器：在同一域名下建立一个代理服务器，将请求转发到目标地址，并在代理服务器上设置 Cookie，然后再将相应结果返回给客户端。

## 浏览器跨域的产生以及如何解决跨域

跨域问题是指在浏览器上，当一个网页的脚本想要访问另外一个不同域名或者端口的网页里的内容时，就会出现跨域问题。这个问题的产生是因为浏览器实现了同源策略（Same Origin Policy），即限制来自不同站点的脚本和文档之间的交互。

为了解决跨域问题，通常可以采用以下几种方法：

1. Jsonp：通过动态插入 script 标签，将需要传递的数据包装成回调函数的参数返回到当前页面中。
2. CORS（跨域资源共享）：服务端设置响应头，允许其它域名的请求访问。
3. 代理：通过在服务器端设置代理，在同一个域下完成数据的传输。
4. WebSocket：WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通信的协议，可以实现跨域通讯。

## **浏览器的垃圾回收机制**

垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存，但闭包在函数执行结束后不会被回收。

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

“进入环境” - 离开环境 回收

跟踪记录每个值被引用的次数 ，次数为0 ，回收

## **哪些情况会导致内存泄漏**

由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中



