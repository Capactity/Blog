#### vue的响应式原理

Vue 的响应式原理是通过“数据劫持”实现的，即通过 Object.defineProperty() 方法将组件的 data 对象中的所有属性转换成 getter 和 setter，从而在属性被访问或者修改时能够触发对应的更新操作。

具体来说，当一个 Vue 实例被创建时，Vue 会遍历该组件的 data 对象中的属性，并使用 Object.defineProperty() 方法为每个属性添加 getter 和 setter。这样，当组件访问一个数据属性时，就会触发该属性的 getter 函数；当组件修改一个数据属性时，就会触发该属性的 setter 函数。同时，Vue 还会为所有的 getter 和 setter 建立一个依赖关系图（Dependency Graph），用于追踪组件和数据之间的关系。

当组件渲染时，Vue 会遍历模板中所有的数据绑定，根据依赖关系图判断该绑定所依赖的数据属性是否发生了变化。如果发生了变化，则会触发对应的更新操作，重新渲染组件。

需要注意的是，Vue 的响应式原理只对组件的 data 对象进行了绑定，并不会对嵌套在 data 中的对象或数组进行劫持。因此，如果需要监听这些对象或数组的变化，需要使用 Vue 提供的$watch() API 或者使用 Vue.set()、Vue.delete() 等方法更新数据。

总结一下，Vue 的响应式原理通过数据劫持实现，即使用 Object.defineProperty() 方法将组件的 data 对象中的所有属性转换成 getter 和 setter，并在访问或修改属性时触发对应的更新操作。同时，Vue 还维护了一个依赖关系图，用于追踪组件和数据之间的关系。通过这种方式，Vue 能够实现高效、灵活的数据双向绑定，从而提高组件的渲染性能和开发效率。

## vue原理

#### nextTick原理

nextTick 的使用场景通常是当我们需要在 DOM 更新完成之后执行一些操作时。比如：

- 当我们需要获取DOM元素的准确位置或尺寸时，因为在DOM更新之后才能正确获取到这些信息。
- 当我们需要在组件更新后对 DOM 进行操作时，例如给某个元素添加 CSS 类、设置样式等。

使用 nextTick 的优势在于它可以让我们避免出现同步代码与异步 DOM 更新顺序不一致的问题。由于 Vue.js 实现了响应式数据绑定，所以在数据发生变化时，Vue.js 会尽可能地异步地执行 DOM 更新。而如果我们需要在 DOM 更新之后执行一些操作，就需要使用 nextTick 来确保这些操作不会被提前执行。

另外，nextTick 的实现原理利用了浏览器的 microtask（微任务）机制，相较于setTimeout或setInterval等基于macrotask（宏任务）的定时器API，nextTick 的性能和效率更高，并且回调函数的执行顺序也更加可控。这也是使用 nextTick 的优势之一。

#### 8  说一下Vue的生命周期

Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 

1beforeCreate（创建前）：

数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。

2created（创建后） ：

实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。

3beforeMount（挂载前）：

在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。

4mounted（挂载后）：

在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。

5beforeUpdate（更新前）：

响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。

6updated（更新后） ：

在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

7beforeDestroy（销毁前）：

实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。

8destroyed（销毁后）：

实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。

另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。

用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。



#### 父子组件的生命周期

父**beforeCreate**->父**created**->父**beforeMount**->子**beforeCreate**->子**created**->子**beforeMount**->子**mounted**->父mounted

#### 9 **组件通信**

（1）父子组件间通信
●子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。
●通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。
●使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。
（2）兄弟组件间通信
●使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。
●通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。
（3）任意组件之间
●使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。



#### 实现双向绑定

我们还是以`Vue`为例，先来看看`Vue`中的双向绑定流程是什么的

1. `new Vue()`首先执行初始化，对`data`执行响应化处理，这个过程发生`Observe`中

2. 同时对模板执行编译，找到其中动态绑定的数据，从`data`中获取并初始化视图，这个过程发生在`Compile`中

3. 同时定义⼀个更新函数和`Watcher`，将来对应数据变化时`Watcher`会调用更新函数

4. 由于`data`的某个`key`在⼀个视图中可能出现多次，所以每个`key`都需要⼀个管家`Dep`来管理多个`Watcher`

5. 将来data中数据⼀旦发生变化，会首先找到对应的`Dep`，通知所有`Watcher`执行更新函数

   

#### 10**Vuex 的原理**

Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。

#### 11 **Vuex中action和mutation的区别**

Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。
●Mutation：必须同步执行；Action：可以异步，但不能直接操作State。
●在视图更新时，先触发actions，actions再触发mutation
●mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters

#### 12 Redux 和 Vuex 有什么区别，它们的共同思想

（1）Redux 和 Vuex区别
●Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可
●Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可
●Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）

通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; 

（2）共同思想
●单—的数据源 
●变化可以预测

本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;
形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;



#### 13 虚拟DOM的解析过程 、 为什么要用虚拟DOM ：

何为虚拟dom

虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。



●首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。

●当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。

●最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。

 14 为什么要用虚拟DOM 

（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能

看一下页面渲染的流程：解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler

下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶

●真实DOM∶ 生成HTML字符串＋重建所有的DOM元素

●虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新



#### vue的优化方案（等同于如何编写可读性高、易维护且高性能的vue代码）

下面是一些编写可读性高、易维护且高性能的Vue代码的优化方案：

1. 合理使用 v-if 和 v-show

v-if 是惰性的，它只有在条件为 true 时才会渲染对应的内容，而 v-show 则是直接在页面上根据条件控制元素的显隐。所以当需要频繁切换组件时，应该优先使用 v-show，这样可以避免重复创建和销毁组件。

1. 避免使用过多的计算属性和监听器（watcher）

计算属性和监听器可以使代码更加简洁明了，但是当它们被频繁使用时，会造成性能问题，所以我们应该尽量减少计算属性和监听器的数量。

1. 使用 key 属性来优化列表渲染效率

在列表数据变化时，Vue 会尝试尽可能地复用已经存在的 DOM 元素，而不是重新渲染整个列表，这样可以提高渲染性能。为了让 Vue 能够正确地复用 DOM 元素，我们需要给每个元素添加一个唯一的 key 属性。

1. 避免使用 index 作为 key 值

使用 index 作为 key 值会导致渲染出错或者重复渲染的情况，所以建议使用具有唯一性的值作为 key。

1. 合理使用异步组件

当应用程序变得越来越庞大时，将整个应用打包成一个巨大的 JavaScript 文件会影响首次加载时间。Vue 提供了异步组件来解决这个问题。通过使用异步组件，可以将应用程序分割成多个小的代码块，使得页面能够更快地渲染出来。

1. 避免频繁操作 DOM

频繁地操作 DOM 会导致浏览器重绘和回流，从而损失性能。尽量减少对 DOM 的操作，使用 Vue 提供的指令和组件来实现需要的效果。

1. 使用 keep-alive 缓存组件

在页面中有一些组件是经常需要被切换的，为了避免每次切换都重新渲染组件，可以使用 keep-alive 组件来缓存组件，从而提高性能。