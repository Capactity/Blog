## Vue 3.0有什么更新？

好的，下面我来具体展开一下 Vue 3.0 中的这些更新。

1. #### 更好的性能

Vue 3.0 引入了响应式系统的重大改进，使用 Proxy 替代了 Object.defineProperty。Proxy 具有更高的性能，并且更加灵活，因为它可以拦截对对象的任何操作。这使得 Vue 能够更快地执行数据变更时的依赖追踪和渲染过程。此外，Vue 3.0 还通过优化虚拟 DOM 和编译器实现了更好的渲染性能。

1. #### Composition API

Composition API 是 Vue 3.0 中引入的一个全新的组件逻辑复用方式。它允许将组件逻辑划分为一组相关功能的逻辑块，从而实现更好的代码复用和可维护性。相比于之前的 Options API，Composition API 可以更好地组织代码结构，并且更容易测试和调试。

1. #### 更好的类型支持

Vue 3.0 增强了对 TypeScript 的支持，这使得在开发时能够更好地检查类型错误，并且提供了更好的 IDE 支持。Vue 3.0 中的所有内置组件和 API 都提供了完整的 TypeScript 类型定义，这使得开发者不再需要手动编写类型定义文件。

1. #### Teleport 组件

Teleport 组件是 Vue 3.0 中新引入的一个组件，它可以帮助开发者轻松地实现像对话框、菜单等可复用组件。Teleport 组件允许开发人员将组件渲染到 DOM 树中的任何位置，而不需要考虑 DOM 结构层级关系。这使得组件的移动和重用变得非常容易。

1. #### 其他优化

除了上述更新外，Vue 3.0 中还包括了其他小的优化和改进，例如更好的 TypeScript 支持、更好的错误处理、更好的调试体验等。例如，Vue 3.0 引入了一个全新的 devtools，使得开发者能够更方便地调试应用程序。此外，Vue 3.0 还提供了更好的错误处理机制，并且提供了更多的警告信息，以帮助开发者更快地解决问题。



#### 2 **Composition API**

Composition API 是 Vue 3 中新增的一种 API 风格，它可以让开发者更方便、更灵活地组织组件逻辑。下面是 Composition API 中常用的一些函数和使用场景：

1. `setup()`：用于初始化组件状态和响应式数据。在 `setup()` 函数中，可以使用 `ref` 或 `reactive` 声明变量并进行初始化，还可以监听其他组件传递过来的 props。
2. `ref()`：用于声明一个基本类型的响应式变量，比如数字、字符串、布尔值等。使用 `ref()` 声明的变量需要通过 `.value` 进行读写操作。
3. `reactive()`：用于声明一个对象类型的响应式变量。使用 `reactive()` 声明的变量会自动将其属性转换为响应式数据。可以使用 `toRefs()` 将一个响应式对象转化为 ref 对象。
4. `computed()`：用于声明一个计算属性。计算属性可以依赖于其他响应式数据，当依赖数据变化时，计算属性会重新计算。
5. `watch()`：用于监听一个响应式数据的变化，并执行相应的回调函数。可以使用 `watchEffect()` 监听多个响应式数据的变化，并执行响应的副作用函数。
6. `provide()` 和 `inject()`：用于实现组件之间的依赖注入。可以在 `provide()` 中声明一个变量或方法，并将它们传递给子组件通过 `inject()` 使用。
7. `onMounted()` 和 `onUnmounted()`：用于在组件挂载和卸载时执行相应的操作。可以在 `onMounted()` 中进行初始化操作，而在 `onUnmounted()` 中进行清理操作。
8. `nextTick()`：用于在 DOM 更新之后执行回调函数。可以使用 `nextTick()` 来确保在需要操作更新后的 DOM 时执行回调函数。

以上是常用的 Composition API 函数及其使用场景，当然还有其他函数和钩子函数，根据实际需求选择合适的 API 进行开发。总的来说，Composition API 让我们更灵活地组织组件逻辑，提高了代码的可读性和可维护性。



**Composition API与React Hook很像**， **区别是什么**

React Hook有以下限制

- 不能在循环、条件、嵌套函数中调用Hook
- 必须确保总是在你的React函数的顶层调用Hook
- useEffect、useMemo等函数必须手动确定依赖关系

而Composition API是基于Vue的响应式系统实现的，与React Hook的相比

- 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，性能也相对于Vue来说也较慢

- Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用

- 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。

  虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。

  

#### 3 Computed 和 Watch 的区别

对于Computed：
●它支持缓存，只有依赖的数据发生了变化，才会重新计算
●不支持异步，当Computed中有异步操作时，无法监听数据的变化
●computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。
●如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
●如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。

对于Watch：
●它不支持缓存，数据变化时，它就会触发相应的操作
●支持异步监听
●监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
●当一个属性发生变化时，就需要执行相应的操作
●监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：
○immediate：组件加载立即触发回调函数
○deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。
当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。

总结：
●computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 
●watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。 





#### vue key 的作用和注意点

在 Vue.js 中，key 属性是用于帮助 Vue 识别列表中的每个子元素的唯一标识符。当使用 v-for 指令进行列表渲染时，Vue 会根据 key 的值来判断哪些元素需要更新、删除或新增。

具体而言，当 Vue 渲染一个包含列表项的组件时，它会为每个列表项创建一个对应的 VNode 对象，并使用 key 属性来标记每个列表项。在下一次重新渲染时，Vue 会遍历新的数据数组并与旧的 VNode 数组进行比较，如果发现旧的 VNode 数组中有某个 VNode 对象的 key 值与新数据数组中的相同，则 Vue 认为这个 VNode 对象被复用了，不需要重新渲染；反之，如果 VNode 对象的 key 值与新数据数组中没有匹配的项，则 Vue 认为这个 VNode 对象需要被销毁或重新创建。

通过使用 key 属性，Vue 可以在列表渲染时更准确地追踪每个子元素的状态变化，从而提高渲染效率和性能。特别是在频繁地添加、删除或移动列表项时，使用 key 属性可以避免不必要的 DOM 操作，从而提升应用程序的响应速度和用户体验。



用index当key会有什么问题？

以下是使用 index 作为 key 可能出现的一些问题：

1. 如果两个元素的内容相同，但位置不同，那么它们的 key 值也会不同，这将会导致 Vue 认为它们是不同的元素，从而重新渲染整个列表。这种情况下，使用 index 作为 key 可能会降低渲染效率，因为 Vue 只是根据位置来判断两个元素是否相同。
2. 如果在列表中添加或删除元素，index 值会发生变化，导致之前匹配上的 VNode 对象（基于其旧的 key 值）无法正确地与新的数据关联起来，而需要进行重新渲染。这样就会导致不必要的 DOM 操作，降低渲染性能。
3. 在嵌套 v-for 循环中，使用 index 作为 key 还可能出现跨级更新的问题，即子组件的 key 值与父组件中同级别的元素的 key 值相同，导致 Vue 无法正确地识别应该复用哪些 VNode 对象，从而出现错误或性能问题。





#### 5 Vue 单页应用与多页应用的区别

概念：
●SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。
●MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。



## React 和 Vue对比

####  对 React 和 Vue 的理解，它们的异同

相似之处：

●都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；
●都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；
●都使用了Virtual DOM（虚拟DOM）提高重绘性能；
●都有props的概念，允许组件间的数据传递；
●都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。

不同之处 ：

1）数据流
Vue默认支持数据双向绑定，而React一直提倡单向数据流 
2）虚拟DOM
Vue2.x开始引入"Virtual DOM"，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 
●Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。
●对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。
3）组件化
React与Vue最大的不同是模板的编写。
●Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。
●React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。

具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。
4）监听数据变化的实现原理不同
●Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能
●React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。
5）高阶组件
react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。



#### **react 和vue router的区别**

React 和 Vue 都提供了路由管理工具，React 的是 React Router，Vue 的是 Vue Router。它们的区别在于：

1. 语法不同：React Router 基于 JSX 语法，而 Vue Router 则是基于 Vue 组件的方式来定义路由。
2. 动态路由的处理方式不同：React Router 将动态参数放在 path 中（例如 /users/:id），而 Vue Router 将动态参数放在路由的 props 中。
3. 路由钩子函数的使用方式不同：React Router 使用类似于 React 组件生命周期函数的方式来使用路由钩子函数，而 Vue Router 则是通过在路由配置对象中定义 beforeEnter、beforeRouteUpdate 等钩子函数来实现。
4. 组件通信方式不同：在 React Router 中，组件之间的通信是通过 props 来实现的，而在 Vue Router 中则可以直接通过 Vuex 状态管理库进行通信。





#### React Hoc/Vue mixin 有什么区别，以及各自的优劣性

React HOC（Higher-Order Component）和 Vue Mixin 都是一种代码重用的技术，它们可以将组件之间的共同逻辑提取出来，并注入到多个不同的组件中。但是它们在实现方式、使用方式和功能上有一些明显的区别。

1. 实现方式

在 React 中，HOC 是一个高阶函数，它接收一个组件作为参数并返回一个新的增强组件。而 Vue Mixin 则是一个普通的 JavaScript 对象，包含数据、方法、生命周期钩子等属性。

1. 使用方式

在 React 中，我们可以使用 HOC 来包装一个组件，然后通过 props 的形式将共同逻辑传递给包装组件和内部组件。在 Vue 中，Mixins 可以被组件引入，在组件选项中通过 mixins 属性进行配置。

1. 功能

React HOC 可以通过组合模式和高阶函数等技术，实现更加灵活和可复用的代码。它可以实现类似于渲染劫持、状态管理、权限控制、错误边界等功能。而 Vue Mixin 也可以提供类似的功能，比如公共方法、computed 属性、生命周期钩子等。

1. 优劣性

React HOC 的优点是能够实现更高度的复用性、更好的拆分和解耦，同时也能够方便地处理状态管理、渲染劫持等方面的问题。但是如果使用过多，会导致组件嵌套层次加深，降低代码可读性。

Vue Mixin 的优点在于可以提供公共方法、数据、生命周期钩子等功能，同时也能够减少代码重复，提高代码的可维护性和可扩展性。但是如果滥用 Mixin，会导致命名冲突和状态管理问题。

总体而言，在 React 中 HOC 更为强大，适合需要更高度抽象的场景；而在 Vue 中 Mixin 的应用更加普遍，适合一些简单场景下的代码复用。开发者应该根据实际情况选择合适的技术方案。



#### react diff算法和vue diff算法的区别

React 的 diff 算法：

React 的 diff 算法是基于比较虚拟 DOM 树的策略。在每次组件更新时，React 会先生成一棵新的虚拟 DOM 树。然后通过对比新旧两棵虚拟 DOM 树的差异，来决定需要进行哪些 DOM 操作。这个过程就叫做 Reconciliation（协调）。

React 的 diff 算法可以说是一种全量算法，因为它需要递归遍历整棵虚拟 DOM 树，并且对于同层级节点的比较也是完全的。具体来说，React 的 diff 算法会按照以下规则进行比较：

1. 若不同类型的元素，则直接替换
2. 若同一类型的元素，则只需要比较其属性和子元素即可，如果有差异则进行更新
3. 若在同一位置上的元素不同，则替换该位置上的元素
4. 若新的元素比旧的多，则添加新的元素
5. 若新的元素比旧的少，则删除多余的元素

Vue 的 diff 算法：

Vue 的 diff 算法采用的是双端比较的方式，即从头和尾同时开始比较节点。这种方式的优势在于可以尽早地发现差异，并且通常情况下能够减少比较次数。Vue 还针对列表渲染做了优化，使用了key的机制来判断同层级节点是否相同，如果key相同，则直接复用旧节点，否则才会重新渲染该节点。

Vue 的 diff 算法大致分为以下几步：

1. 查找新旧节点的最长公共子序列（LCS）
2. 如果 LSC 中的节点不需要移动，则直接更新其属性和子元素
3. 如果 LSC 中的节点需要移动，则进行移动操作
4. 对于剩余的未处理节点，有新增节点和删除节点两种情况
5. 新增节点通过插入操作完成，删除节点通过删除操作完成

总结：

React 和 Vue 的 diff 算法在实现细节上略有不同，但都是非常优秀的算法。React 的 diff 算法采用全量比较的方式，可以保证准确性，但在组件树较大时可能会出现性能问题；而 Vue 的 diff 算法采用双端比较的方式以及 key 机制，可以尽早发现差异并减少比较次数，从而提高性能。因此，在实际项目中，需要根据具体的场景选择合适的框架和算法。



#### 7 对 SPA 单页面的理解，它的优缺点分别是什么？

SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

优点：
●用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
●基于上面一点，SPA 相对对服务器压力小；
●前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

缺点：
●初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
●前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
●SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。





#### vue的响应式原理

Vue 的响应式原理是通过“数据劫持”实现的，即通过 Object.defineProperty() 方法将组件的 data 对象中的所有属性转换成 getter 和 setter，从而在属性被访问或者修改时能够触发对应的更新操作。

具体来说，当一个 Vue 实例被创建时，Vue 会遍历该组件的 data 对象中的属性，并使用 Object.defineProperty() 方法为每个属性添加 getter 和 setter。这样，当组件访问一个数据属性时，就会触发该属性的 getter 函数；当组件修改一个数据属性时，就会触发该属性的 setter 函数。同时，Vue 还会为所有的 getter 和 setter 建立一个依赖关系图（Dependency Graph），用于追踪组件和数据之间的关系。

当组件渲染时，Vue 会遍历模板中所有的数据绑定，根据依赖关系图判断该绑定所依赖的数据属性是否发生了变化。如果发生了变化，则会触发对应的更新操作，重新渲染组件。

需要注意的是，Vue 的响应式原理只对组件的 data 对象进行了绑定，并不会对嵌套在 data 中的对象或数组进行劫持。因此，如果需要监听这些对象或数组的变化，需要使用 Vue 提供的$watch() API 或者使用 Vue.set()、Vue.delete() 等方法更新数据。

总结一下，Vue 的响应式原理通过数据劫持实现，即使用 Object.defineProperty() 方法将组件的 data 对象中的所有属性转换成 getter 和 setter，并在访问或修改属性时触发对应的更新操作。同时，Vue 还维护了一个依赖关系图，用于追踪组件和数据之间的关系。通过这种方式，Vue 能够实现高效、灵活的数据双向绑定，从而提高组件的渲染性能和开发效率。



## vue原理



#### nextTick原理

nextTick 的使用场景通常是当我们需要在 DOM 更新完成之后执行一些操作时。比如：

- 当我们需要获取DOM元素的准确位置或尺寸时，因为在DOM更新之后才能正确获取到这些信息。
- 当我们需要在组件更新后对 DOM 进行操作时，例如给某个元素添加 CSS 类、设置样式等。

使用 nextTick 的优势在于它可以让我们避免出现同步代码与异步 DOM 更新顺序不一致的问题。由于 Vue.js 实现了响应式数据绑定，所以在数据发生变化时，Vue.js 会尽可能地异步地执行 DOM 更新。而如果我们需要在 DOM 更新之后执行一些操作，就需要使用 nextTick 来确保这些操作不会被提前执行。

另外，nextTick 的实现原理利用了浏览器的 microtask（微任务）机制，相较于setTimeout或setInterval等基于macrotask（宏任务）的定时器API，nextTick 的性能和效率更高，并且回调函数的执行顺序也更加可控。这也是使用 nextTick 的优势之一。





#### 8  说一下Vue的生命周期

Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 

1beforeCreate（创建前）：

数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。

2created（创建后） ：

实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。

3beforeMount（挂载前）：

在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。

4mounted（挂载后）：

在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。

5beforeUpdate（更新前）：

响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。

6updated（更新后） ：

在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

7beforeDestroy（销毁前）：

实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。

8destroyed（销毁后）：

实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。

另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。

用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。



#### 父子组件的生命周期

父**beforeCreate**->父**created**->父**beforeMount**->子**beforeCreate**->子**created**->子**beforeMount**->子**mounted**->父mounted



#### 9 **组件通信**

（1）父子组件间通信
●子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。
●通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。
●使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。
（2）兄弟组件间通信
●使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。
●通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。
（3）任意组件之间
●使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。



#### 实现双向绑定

我们还是以`Vue`为例，先来看看`Vue`中的双向绑定流程是什么的

1. `new Vue()`首先执行初始化，对`data`执行响应化处理，这个过程发生`Observe`中

2. 同时对模板执行编译，找到其中动态绑定的数据，从`data`中获取并初始化视图，这个过程发生在`Compile`中

3. 同时定义⼀个更新函数和`Watcher`，将来对应数据变化时`Watcher`会调用更新函数

4. 由于`data`的某个`key`在⼀个视图中可能出现多次，所以每个`key`都需要⼀个管家`Dep`来管理多个`Watcher`

5. 将来data中数据⼀旦发生变化，会首先找到对应的`Dep`，通知所有`Watcher`执行更新函数

   

#### 10**Vuex 的原理**

Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。

#### 11 **Vuex中action和mutation的区别**

Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。
●Mutation：必须同步执行；Action：可以异步，但不能直接操作State。
●在视图更新时，先触发actions，actions再触发mutation
●mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters

#### 12 Redux 和 Vuex 有什么区别，它们的共同思想

（1）Redux 和 Vuex区别
●Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可
●Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可
●Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）

通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; 

（2）共同思想
●单—的数据源 
●变化可以预测

本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;
形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;



#### 13 虚拟DOM的解析过程 、 为什么要用虚拟DOM ：

何为虚拟dom

虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。



●首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。

●当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。

●最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。

 14 为什么要用虚拟DOM 

（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能

看一下页面渲染的流程：解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler

下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶

●真实DOM∶ 生成HTML字符串＋重建所有的DOM元素

●虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新









#### vue的优化方案（等同于如何编写可读性高、易维护且高性能的vue代码）

下面是一些编写可读性高、易维护且高性能的Vue代码的优化方案：

1. 合理使用 v-if 和 v-show

v-if 是惰性的，它只有在条件为 true 时才会渲染对应的内容，而 v-show 则是直接在页面上根据条件控制元素的显隐。所以当需要频繁切换组件时，应该优先使用 v-show，这样可以避免重复创建和销毁组件。

1. 避免使用过多的计算属性和监听器（watcher）

计算属性和监听器可以使代码更加简洁明了，但是当它们被频繁使用时，会造成性能问题，所以我们应该尽量减少计算属性和监听器的数量。

1. 使用 key 属性来优化列表渲染效率

在列表数据变化时，Vue 会尝试尽可能地复用已经存在的 DOM 元素，而不是重新渲染整个列表，这样可以提高渲染性能。为了让 Vue 能够正确地复用 DOM 元素，我们需要给每个元素添加一个唯一的 key 属性。

1. 避免使用 index 作为 key 值

使用 index 作为 key 值会导致渲染出错或者重复渲染的情况，所以建议使用具有唯一性的值作为 key。

1. 合理使用异步组件

当应用程序变得越来越庞大时，将整个应用打包成一个巨大的 JavaScript 文件会影响首次加载时间。Vue 提供了异步组件来解决这个问题。通过使用异步组件，可以将应用程序分割成多个小的代码块，使得页面能够更快地渲染出来。

1. 避免频繁操作 DOM

频繁地操作 DOM 会导致浏览器重绘和回流，从而损失性能。尽量减少对 DOM 的操作，使用 Vue 提供的指令和组件来实现需要的效果。

1. 使用 keep-alive 缓存组件

在页面中有一些组件是经常需要被切换的，为了避免每次切换都重新渲染组件，可以使用 keep-alive 组件来缓存组件，从而提高性能。