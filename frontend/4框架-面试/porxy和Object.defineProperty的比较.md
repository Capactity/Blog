## 对比

#### porxy和Object.defineProperty的比较：

`Object.defineProperty` 

优势：

主要在于它可以直接修改对象属性的行为，包括属性的可读性、可写性和枚举性等。这使得您可以对属性进行细粒度的控制和修改

1. 实现简单：`Object.defineProperty` 是一个原生 JavaScript 方法，易于使用和学习。
2. 良好的浏览器兼容性：`Object.defineProperty` 支持所有主流浏览器，包括旧版浏览器。
3. 高度可定制：该方法允许您定义属性的特性

缺点：

首先，它仅适用于单个属性的修改，如果需要修改多个属性，则必须多次调用该方法。其次，它不能拦截对象上的其他操作，例如属性访问以外的函数调用或删除等。

1. 属性新增或删除不能被检测：`Object.defineProperty` 只能拦截对象已有属性的访问和更改，无法检测到属性的添加或删除。如果需要检测新属性的添加或删除，则需要使用其他技术。
2. 深度监听需递归处理：当对象中嵌套了多层子属性时，`Object.defineProperty` 的深度监听需要递归处理，这可能会导致性能问题。
3. 占用内存较大：为了跟踪对象的变化，Vue.js 在内部维护了一个与原对象结构相同的响应式对象。这使得 Vue.js 响应式系统占用的内存比起普通对象更大。



`Proxy` 拥有更广泛的能力和更大的灵活性。使用 `Proxy`，

优势：

您可以全面控制对象的行为，包括属性访问、函数调用和删除等。此外，您可以使用 `Proxy` 对象实现各种高级功能，例如数据绑定、惰性计算、缓存和日志记录等。而且，`Proxy` 可以通过捕获异常来提供自定义错误处理。

1. 更好的性能：与 `Object.defineProperty` 不同，`Proxy` 可以拦截整个对象的所有属性访问和修改操作，而无需递归处理嵌套属性。这使得 Vue.js 响应式系统更加高效。
2. 能够检测到属性添加和删除操作：相比之下，`Proxy` 可以拦截对象上的所有操作，包括属性的添加和删除，这一点是 `Object.defineProperty` 所不能做到的。
3. 更好的错误提示：由于 `Proxy` 可以捕获异常并提供自定义错误处理，因此当您意外地对非响应式对象进行操作时，Vue.js 可以更好地提示错误信息。
4. 更好的可扩展性：使用 `Proxy`，您可以通过编写拦截器函数来控制对象的行为，并实现各种高级功能，例如数据绑定、惰性计算、缓存和日志记录等。

缺点：

1. 兼容性问题：早期的浏览器并不支持 Proxy，因此在这些浏览器上运行时会有兼容性问题。
2. 对象属性监听限制：Proxy 只能监听对象属性的变化，无法监听数组的变化，因此需要通过其他方式来处理数组变化的情况，比如使用 Vue3 提供的 reactive() 函数。
3. 多层嵌套监听问题：Proxy 监听对象属性变化的功能是自动递归的，但如果对象中嵌套了多层对象，监听起来可能会比较麻烦，也容易出现性能问题。
4. 静态属性监听限制：由于 Proxy 只能监听对象属性的变化，因此无法监听静态属性的变化。
5. 动态添加属性限制：使用 Proxy 监听对象属性的变化时，只能监听已经存在的属性，无法监听后续添加的属性变化。这意味着如果要监听一个对象中所有属性的变化，就必须提前将所有可能出现的属性都定义好。


