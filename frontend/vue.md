## Vue 3.0有什么更新？

好的，下面我来具体展开一下 Vue 3.0 中的这些更新。

1. #### 更好的性能

Vue 3.0 引入了响应式系统的重大改进，使用 Proxy 替代了 Object.defineProperty。Proxy 具有更高的性能，并且更加灵活，因为它可以拦截对对象的任何操作。这使得 Vue 能够更快地执行数据变更时的依赖追踪和渲染过程。此外，Vue 3.0 还通过优化虚拟 DOM 和编译器实现了更好的渲染性能。

1. #### Composition API

Composition API 是 Vue 3.0 中引入的一个全新的组件逻辑复用方式。它允许将组件逻辑划分为一组相关功能的逻辑块，从而实现更好的代码复用和可维护性。相比于之前的 Options API，Composition API 可以更好地组织代码结构，并且更容易测试和调试。

1. #### 更好的类型支持

Vue 3.0 增强了对 TypeScript 的支持，这使得在开发时能够更好地检查类型错误，并且提供了更好的 IDE 支持。Vue 3.0 中的所有内置组件和 API 都提供了完整的 TypeScript 类型定义，这使得开发者不再需要手动编写类型定义文件。

1. #### Teleport 组件

Teleport 组件是 Vue 3.0 中新引入的一个组件，它可以帮助开发者轻松地实现像对话框、菜单等可复用组件。Teleport 组件允许开发人员将组件渲染到 DOM 树中的任何位置，而不需要考虑 DOM 结构层级关系。这使得组件的移动和重用变得非常容易。

1. #### 其他优化

除了上述更新外，Vue 3.0 中还包括了其他小的优化和改进，例如更好的 TypeScript 支持、更好的错误处理、更好的调试体验等。例如，Vue 3.0 引入了一个全新的 devtools，使得开发者能够更方便地调试应用程序。此外，Vue 3.0 还提供了更好的错误处理机制，并且提供了更多的警告信息，以帮助开发者更快地解决问题。



#### proxy的实现

Vue 3.x 中使用 Proxy 对象来代替 Vue 2.x 中的 Object.defineProperty 来进行数据劫持，从而实现响应式数据。Proxy 是 ES6 新增的特性，它可以在不改变原对象的情况下拦截并返回对该对象属性的访问、赋值等操作。

具体来说，Vue 在创建响应式对象时，会通过 Proxy 对象创建一个代理对象 proxy，并将原对象 obj 和代理对象 proxy 建立映射关系，这样当我们对代理对象 proxy 进行属性的读取、赋值等操作时，就会被代理对象拦截到，从而触发相应的更新操作。

举个例子，当我们通过以下方式创建一个响应式对象：

```
javascriptCopy Codeconst reactiveObj = reactive({
  name: '小明',
  age: 18
})
```

Vue 内部实际上会通过 Proxy 实现一个代理对象：

```
javascriptCopy Codeconst handler = {
  get(target, property) {
    //...
  },
  set(target, property, value) {
    //...
  }
}

const reactiveObj = new Proxy({
  name: '小明',
  age: 18
}, handler)
```

其中 handler 就是代理对象的一个处理器，在读取或设置代理对象的属性时会被调用。具体来说，handler 中的 get() 方法会在读取代理对象的属性时被调用，set() 方法会在给代理对象的属性赋值时被调用。这样，当我们对 reactiveObj 中的属性进行读取或赋值时，实际上是在访问或修改代理对象 proxy 中的对应属性，从而触发响应式更新。



## 对比

#### porxy和Object.defineProperty的比较：

`Object.defineProperty` 

##### 优势：

主要在于它可以直接修改对象属性的行为，包括属性的可读性、可写性和枚举性等。这使得您可以对属性进行细粒度的控制和修改。此外，它是 ECMAScript 5 标准中的一部分，支持所有符合该标准的 JavaScript 引擎。

1. 实现简单：`Object.defineProperty` 是一个原生 JavaScript 方法，易于使用和学习。
2. 良好的浏览器兼容性：`Object.defineProperty` 支持所有主流浏览器，包括旧版浏览器。
3. 高度可定制：该方法允许您定义属性的特性，例如可读性、可写性和枚举性等。这使得您可以对属性进行细粒度的控制和修改。

##### 缺点：

首先，它仅适用于单个属性的修改，如果需要修改多个属性，则必须多次调用该方法。其次，它不能拦截对象上的其他操作，例如属性访问以外的函数调用或删除等。

1. 属性新增或删除不能被检测：`Object.defineProperty` 只能拦截对象已有属性的访问和更改，无法检测到属性的添加或删除。如果需要检测新属性的添加或删除，则需要使用其他技术。
2. 深度监听需递归处理：当对象中嵌套了多层子属性时，`Object.defineProperty` 的深度监听需要递归处理，这可能会导致性能问题。
3. 占用内存较大：为了跟踪对象的变化，Vue.js 在内部维护了一个与原对象结构相同的响应式对象。这使得 Vue.js 响应式系统占用的内存比起普通对象更大。



`Proxy` 拥有更广泛的能力和更大的灵活性。使用 `Proxy`，

##### 优势：

您可以全面控制对象的行为，包括属性访问、函数调用和删除等。此外，您可以使用 `Proxy` 对象实现各种高级功能，例如数据绑定、惰性计算、缓存和日志记录等。而且，`Proxy` 可以通过捕获异常来提供自定义错误处理。

1. 更好的性能：与 `Object.defineProperty` 不同，`Proxy` 可以拦截整个对象的所有属性访问和修改操作，而无需递归处理嵌套属性。这使得 Vue.js 响应式系统更加高效。
2. 能够检测到属性添加和删除操作：相比之下，`Proxy` 可以拦截对象上的所有操作，包括属性的添加和删除，这一点是 `Object.defineProperty` 所不能做到的。
3. 更好的错误提示：由于 `Proxy` 可以捕获异常并提供自定义错误处理，因此当您意外地对非响应式对象进行操作时，Vue.js 可以更好地提示错误信息。
4. 更好的可扩展性：使用 `Proxy`，您可以通过编写拦截器函数来控制对象的行为，并实现各种高级功能，例如数据绑定、惰性计算、缓存和日志记录等。

##### 缺点：

1. 兼容性问题：早期的浏览器并不支持 Proxy，因此在这些浏览器上运行时会有兼容性问题。
2. 对象属性监听限制：Proxy 只能监听对象属性的变化，无法监听数组的变化，因此需要通过其他方式来处理数组变化的情况，比如使用 Vue3 提供的 reactive() 函数。
3. 多层嵌套监听问题：Proxy 监听对象属性变化的功能是自动递归的，但如果对象中嵌套了多层对象，监听起来可能会比较麻烦，也容易出现性能问题。
4. 静态属性监听限制：由于 Proxy 只能监听对象属性的变化，因此无法监听静态属性的变化。
5. 动态添加属性限制：使用 Proxy 监听对象属性的变化时，只能监听已经存在的属性，无法监听后续添加的属性变化。这意味着如果要监听一个对象中所有属性的变化，就必须提前将所有可能出现的属性都定义好。



#### Vue 3的Diff算法与Vue 2的Diff算法有几个重要区别：

1. PatchFlag：Vue 3在VNode上引入了PatchFlag标记，用于记录节点类型和属性变更。这使得Vue 3可以跳过不需要更新的节点，从而提高了渲染性能。
2. 静态提升：Vue 3中静态节点的处理方式也有所不同。在编译阶段，Vue 3会将静态节点提升为常量，从而减少运行时的计算和创建过程，提高渲染性能。
3. 缓存事件处理函数：在Vue 3中，事件处理函数被缓存起来，避免了每次都重新创建事件处理函数的开销。
4. 模板编译优化：Vue 3中模板编译器进行了大量优化，生成的代码更加高效，同时还支持了一些新的特性，如Fragments和Teleport等。

总体而言，Vue 3的Diff算法在渲染性能、内存利用率和开发体验方面都有很大的提升，是Vue框架的一个重要进化。





#### 2 **Composition API**

Composition API 是 Vue 3 中新增的一种 API 风格，它可以让开发者更方便、更灵活地组织组件逻辑。下面是 Composition API 中常用的一些函数和使用场景：

1. `setup()`：用于初始化组件状态和响应式数据。在 `setup()` 函数中，可以使用 `ref` 或 `reactive` 声明变量并进行初始化，还可以监听其他组件传递过来的 props。
2. `ref()`：用于声明一个基本类型的响应式变量，比如数字、字符串、布尔值等。使用 `ref()` 声明的变量需要通过 `.value` 进行读写操作。
3. `reactive()`：用于声明一个对象类型的响应式变量。使用 `reactive()` 声明的变量会自动将其属性转换为响应式数据。可以使用 `toRefs()` 将一个响应式对象转化为 ref 对象。
4. `computed()`：用于声明一个计算属性。计算属性可以依赖于其他响应式数据，当依赖数据变化时，计算属性会重新计算。
5. `watch()`：用于监听一个响应式数据的变化，并执行相应的回调函数。可以使用 `watchEffect()` 监听多个响应式数据的变化，并执行响应的副作用函数。
6. `provide()` 和 `inject()`：用于实现组件之间的依赖注入。可以在 `provide()` 中声明一个变量或方法，并将它们传递给子组件通过 `inject()` 使用。
7. `onMounted()` 和 `onUnmounted()`：用于在组件挂载和卸载时执行相应的操作。可以在 `onMounted()` 中进行初始化操作，而在 `onUnmounted()` 中进行清理操作。
8. `nextTick()`：用于在 DOM 更新之后执行回调函数。可以使用 `nextTick()` 来确保在需要操作更新后的 DOM 时执行回调函数。

以上是常用的 Composition API 函数及其使用场景，当然还有其他函数和钩子函数，根据实际需求选择合适的 API 进行开发。总的来说，Composition API 让我们更灵活地组织组件逻辑，提高了代码的可读性和可维护性。



**Composition API与React Hook很像**， **区别是什么**

React Hook有以下限制

- 不能在循环、条件、嵌套函数中调用Hook
- 必须确保总是在你的React函数的顶层调用Hook
- useEffect、useMemo等函数必须手动确定依赖关系

而Composition API是基于Vue的响应式系统实现的，与React Hook的相比

- 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，性能也相对于Vue来说也较慢

- Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用

- 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。

  虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。

  

#### 3 Computed 和 Watch 的区别

对于Computed：
●它支持缓存，只有依赖的数据发生了变化，才会重新计算
●不支持异步，当Computed中有异步操作时，无法监听数据的变化
●computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。
●如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
●如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。

对于Watch：
●它不支持缓存，数据变化时，它就会触发相应的操作
●支持异步监听
●监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
●当一个属性发生变化时，就需要执行相应的操作
●监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：
○immediate：组件加载立即触发回调函数
○deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。
当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。

总结：
●computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 
●watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。 



#### 4 Computed 和 Methods 的区别

可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 

不同点： 
●computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；
●method 调用总会执行该函数。



#### 5 Vue 单页应用与多页应用的区别

概念：
●SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。
●MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。



## React 和 Vue对比

####  对 React 和 Vue 的理解，它们的异同

相似之处：

●都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；
●都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；
●都使用了Virtual DOM（虚拟DOM）提高重绘性能；
●都有props的概念，允许组件间的数据传递；
●都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。

不同之处 ：

1）数据流
Vue默认支持数据双向绑定，而React一直提倡单向数据流 
2）虚拟DOM
Vue2.x开始引入"Virtual DOM"，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 
●Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。
●对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。
3）组件化
React与Vue最大的不同是模板的编写。
●Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。
●React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。

具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。
4）监听数据变化的实现原理不同
●Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能
●React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。
5）高阶组件
react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。



#### **react 和vue router的区别**

React 和 Vue 都提供了路由管理工具，React 的是 React Router，Vue 的是 Vue Router。它们的区别在于：

1. 语法不同：React Router 基于 JSX 语法，而 Vue Router 则是基于 Vue 组件的方式来定义路由。
2. 动态路由的处理方式不同：React Router 将动态参数放在 path 中（例如 /users/:id），而 Vue Router 将动态参数放在路由的 props 中。
3. 路由钩子函数的使用方式不同：React Router 使用类似于 React 组件生命周期函数的方式来使用路由钩子函数，而 Vue Router 则是通过在路由配置对象中定义 beforeEnter、beforeRouteUpdate 等钩子函数来实现。
4. 组件通信方式不同：在 React Router 中，组件之间的通信是通过 props 来实现的，而在 Vue Router 中则可以直接通过 Vuex 状态管理库进行通信。





#### 7 对 SPA 单页面的理解，它的优缺点分别是什么？

SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

优点：
●用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
●基于上面一点，SPA 相对对服务器压力小；
●前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

缺点：
●初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
●前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
●SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。



#### 8  说一下Vue的生命周期

Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 

1beforeCreate（创建前）：

数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。

2created（创建后） ：

实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。

3beforeMount（挂载前）：

在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。

4mounted（挂载后）：

在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。

5beforeUpdate（更新前）：

响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。

6updated（更新后） ：

在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

7beforeDestroy（销毁前）：

实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。

8destroyed（销毁后）：

实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。

另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。

用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。



#### 父子组件的生命周期

父**beforeCreate**->父**created**->父**beforeMount**->子**beforeCreate**->子**created**->子**beforeMount**->子**mounted**->父mounted



#### 9 **组件通信**

（1）父子组件间通信
●子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。
●通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。
●使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。
（2）兄弟组件间通信
●使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。
●通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。
（3）任意组件之间
●使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。



#### 实现双向绑定

我们还是以`Vue`为例，先来看看`Vue`中的双向绑定流程是什么的

1. `new Vue()`首先执行初始化，对`data`执行响应化处理，这个过程发生`Observe`中

2. 同时对模板执行编译，找到其中动态绑定的数据，从`data`中获取并初始化视图，这个过程发生在`Compile`中

3. 同时定义⼀个更新函数和`Watcher`，将来对应数据变化时`Watcher`会调用更新函数

4. 由于`data`的某个`key`在⼀个视图中可能出现多次，所以每个`key`都需要⼀个管家`Dep`来管理多个`Watcher`

5. 将来data中数据⼀旦发生变化，会首先找到对应的`Dep`，通知所有`Watcher`执行更新函数

   

#### 10**Vuex 的原理**

Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。

#### 11 **Vuex中action和mutation的区别**

Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。
●Mutation：必须同步执行；Action：可以异步，但不能直接操作State。
●在视图更新时，先触发actions，actions再触发mutation
●mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters

#### 12 Redux 和 Vuex 有什么区别，它们的共同思想

（1）Redux 和 Vuex区别
●Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可
●Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可
●Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）

通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; 

（2）共同思想
●单—的数据源 
●变化可以预测

本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;
形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;



#### 13 虚拟DOM的解析过程 、 为什么要用虚拟DOM ：

何为虚拟dom

虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。



●首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。

●当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。

●最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。

 14 为什么要用虚拟DOM 

（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能

看一下页面渲染的流程：解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler

下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶

●真实DOM∶ 生成HTML字符串＋重建所有的DOM元素

●虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新



#### 14 DIFF算法的原理

在新老虚拟DOM对比时：
●首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
●如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
●比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。
●匹配时，找到相同的子节点，递归比较子节点

在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。