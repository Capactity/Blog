### Python的基本数据类型

Python3 中有六个标准的数据类型：

- Number（数字）(包括整型、浮点型、复数、布尔型等)
- String（字符串）
- List（列表）
- Tuple（元组）
- Set（集合）
- Dictionary（字典）

Python3 的六个标准数据类型中：

- 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
- 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。



### Python是静态还是动态类型？是强类型还是弱类型？

- 动态强类型语言（不少人误以为是弱类型）
- 动态还是静态指的是编译器还是运行期确定类型
- 强类型指的是不会发生隐式类型转换

js就是典型的弱类型语言，例如在console下面模拟一下数字和字符串相加，会发现发生了类型转换。

而Python会报TypeError



### GIL是什么

GIL 的全名是 the Global Interpreter Lock （全局解释锁），用于保护 Python 内部对象的全局锁（在进程空间中唯一），保障了解释器的线程安全。

````
我们把整个进程空间看做一个车间，把线程看成是多条不相交的流水线，把线程控制流中的字节码看作是流水线上待处理的物品。Python 解释器是工
人，整个车间仅此一名。操作系统是一只上帝之手，会随时把工人从一条流水线调到另一条——这种“随时”是不由分说的，即不管处理完当前物品与
否。
若没有 GIL。假设工人正在流水线 A 处理 A1 物品，根据 A1 的需要将房间温度（一个全局对象）调到了 20 度。这时上帝之手发动了，工人被调到流
水线 B 处理 B1 物品，根据 B1 的需要又将房间温度调到了 50 度。这时上帝之手又发动了，工人又调回 A 继续处理 A1。但此时 A1 暴露在了 50 度的
环境中，安全问题就此产生了。

而 GIL 相当于一条锁链，一旦工人开始处理某条流水线上的物品，GIL 便会将工人和该流水线锁在一起。而被锁住的工人只会处理该流水线上的物品。
就算突然被调到另一条流水线，他也不会干活，而是干等至重新调回原来的流水线。这样每个物品在被处理的过程中便总是能保证全局环境不会突变。
````

GIL 保证了线程安全性，但很显然也带来了一个问题：每个时刻只有一条线程在执行，即使在多核架构中也是如此——毕竟，解释器只有一个。如此一来，单进程的 Python 程序便无法利用到多核的优势了。



### 如何解决？

使用多进程
线程间会竞争资源是因为它们共享同一个进程空间，但进程的内存空间是独立的，自然也就没有必要使用解释锁了。

许多人非常忌讳使用多进程，理由是进程操作（创建、切换）的时间开销太大了，而且会占用更多的内存。这种担心其实没有必要——除非是对并发量要求很高的应用（如服务器），多进程增加的时空开销其实都在可以接受的范围中。更何况，我们可以使用进程池减少频繁创建进程带来的开销。




## 什么是[多线程](https://so.csdn.net/so/search?q=多线程&spm=1001.2101.3001.7020)、多进程、守护线程

##### 进程就是一段程序的执行过程。

进程状态：进程有三个状态，就绪、运行和阻塞

##### 线程

当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行流的最小单元，当设置多线程时，主线程会创建多个子线程，在python中，默认情况下（其实就是setDaemon(False)），主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束



##### 多线程

在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。

最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢。多线程的出现就是为了提高效率。


##### 守护线程

守护线程与普通线程的唯一区别是：当所有的线程都是守护线程的时候，主线程就可以退出了；如果还有一个或以上的非守护线程则不会退出。

设置子线程为守护线程时，主线程一旦执行结束，则全部线程全部被终止执行，可能出现的情况就是，子线程的任务还没有完全执行结束，就被迫停止



#### 进程与线程的区别

1简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2线程的划分尺度小于进程，使得多线程程序的并发性高。

3另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。



## Python中threading的使用注意事项

在测试用例中，子线程的任务是停顿5秒后打印线程名字以及时间；主线程的任务是循环打印5次线程名以及时间。

主线程和子线程分别在执行，约在主线程执行完5秒后子线程也执行完毕。

### 设置守护线程

添加一行守护进程的代码“t1.setDaemon(True)”。

发现主线程快速执行完毕，但是由于子线程耗时较长，主线程执行完的时候子线程还未结束，不过主线程执行完直接结束了程序，不会等待子线程

### join()方法

只是添加了join函数一行代码，我们发现主线程和子线程执行的顺序就改变了。线程 t1 start后，主线程停在了join()方法处，等sleep（10）后，线程t1操作结束被join，接着，主线程继续循环打印



### 同时使用守护线程和join函数

主线程一直等待全部的子线程结束之后，主线程自身才结束，程序退出。