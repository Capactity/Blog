## webpack如何优化前端性能

- 压缩代码:删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的`UglifyJsPlugin`和`ParallelUglifyPlugin`来压缩JS文件， 利用`cssnano`（css-loader?minimize）来压缩css
- 利用CDN加速: 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于`output`参数和各loader的`publicPath`参数来修改资源路径
- Tree Shaking: 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数`--optimize-minimize`来实现
- Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利用浏览器缓存
- 提取公共第三方库: SplitChunksPlugin插件来进行公共模块抽取,利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码

## 微前端的应用通信方案？

1. 基于URL通信，能力较弱，但是有些简单场景还是很好用的，例如主应用需要识别渲染哪个子应用可以在URL地址栏加上子应用id，当子应用内部有一个跳转逻辑的时候直接修改这个参数就可以了
2. 基于storage，这种方式虽然可以互通某些数据，但是不能做到实时相应
3. 发布订阅模型，利用自定义事件实现一套通信机制
4. 基于props传参的模式，所有微应用与主应用通信，主应用再通知微应用，这种方式耦合性比较强

## 微前端如何进行安全隔离？

微前端中的安全隔离分为样式隔离和脚本隔离；如果使用了全局样式那么主应用与子应用之间可能产生样式污染；js脚本则主要是全局变量的污染；

样式隔离有以下方案：

1. 动态样式表，应用卸载之后样式也同时卸载；这种方式需要注意的问题是微应用卸载时也要通知主应用将微应用的样式卸载掉，如果卸载不成功则会造成样式污染
2. 工程化手段：css module，css in js，无法杜绝项目中使用全局样式，可能需要我们约定只能在主应用中修改全局组件样式
3. shadow DOM，天然的样式隔离
4. 运行时样式转换：运行时给所有节点增加一个属性，利用属性选择器创建命名空间div[data-qiankun-subvue1]
5. BEM约束，或者编译时增加namespace

js隔离

1. 存储js变更的快照，等到应用卸载之后还原快照，例如Qiankun
2. 借助iframe实现，例如各大线上编辑器都是用iframe嵌入html页面
3. 借助Worker

Worker自然拥有js沙箱环境，但是Worker中无法访问dom对象，所以我们可以通过编译“注入”document上下文，也就是说我们在Worker中进行dom的操作最终会编译到主线程去操作，但是变量依然是寄存在Worker中；当前还没有很好的框架去封装这个功能，让我们期待一下；

