## **数据类型检测的方式有哪些**

**（1）typeof**：其中数组、对象、null都会被判断为object，其他判断都正确。

**（2）instanceof**：instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。

**（3） constructor**：有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了。

**（4）Object.prototype.toString.call()**: 使用 Object 对象的原型方法 toString 来判断数据类型

##  对原型、原型链的理解

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。

## **对闭包的理解**

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量,比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。

## **对作用域、作用域链的理解**

**1全局作用域和函数作用域**

**2块级作用域**：使用ES6中新增的let和const指令可以声明块级作用域

**作用域链：**
在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

## 执行上下文栈

JavaScript引擎使用执行上下文栈来管理执行上下文。
当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

## 对this对象的理解

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

1 第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
2 第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
3 第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
4 第四种是 apply 、 call 和 bind 调用模式

## call() 和 apply() 的区别？

它们的作用一模一样，区别仅在于传入参数的形式的不同。
●apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。
●call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。



#### **什么是dom和bom**

DOM 指的是文档对象模型，这个对象主要定义了处理网页内容的方法和接口。
BOM 指的是浏览器对象模型，定义了与浏览器进行交互的法和接口。BOM的核心是 window

#### **js为什么要变量提升，导致了什么问题？**

造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象。

那为什么会进行变量提升呢？主要有以下两个原因：提高性能（语法检查和预编译），容错性更好。

#### **for...in和for...of的区别**

for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名

for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。

#### **数据类型检测方式有哪些**

**（1）typeof**、**（2）instanceof**、**（3） constructor**、**（4）Object.prototype.toString.call()**

**Let、const、var的区别**

#### **对原型、原型链的理解**

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。

**原型链指向**



#### **async/await和promise的优劣势**

代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 
●Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 
●错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余 
●调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。 

#### **闭包的理解**

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量,比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。

#### **作用域、作用域链的理解**

**1全局作用域和函数作用域**

**2块级作用域**：使用ES6中新增的let和const指令可以声明块级作用域

**作用域链：**
在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

#### **执行上下文的理解**

JavaScript引擎使用执行上下文栈来管理执行上下文。
当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

#### **call、apply、bind的区别，实现函数**

apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合

call 传入的参数数量不固定，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。

#### 协商缓存和强缓存

协商缓存和强缓存是HTTP中常用的两种缓存机制，它们都可以优化网站性能和减少网络请求。不过二者的实现方式略有不同。

强缓存：当浏览器发起第一次请求时，服务器会在返回响应头中添加Expires或Cache-Control字段来标识该资源的过期时间（即缓存时间），客户端再次请求该资源时，如果当前时间还在缓存时间内，则直接从浏览器缓存中返回，不会再向服务器发送请求。如果已经过了缓存时间，浏览器会把缓存数据标记为过期，并向服务器发送请求获取最新数据。Expires是HTTP/1.0的规范，而Cache-Control则是HTTP/1.1的规范。

协商缓存：当浏览器发起请求时，服务器返回响应头中的ETag或Last-Modified字段来标识该资源的唯一标识和最后修改时间，客户端再次请求该资源时会带上If-None-Match和If-Modified-Since字段携带之前获取到的数据并告诉服务器“我想要的是xx版本的数据”以便服务器判断是否需要重新向客户端返回更新的数据。

由于协商缓存需要与服务端进行交互，所以相对于强缓存，协商缓存会增加一定的延迟，但协商缓存可以更加精确地控制数据的更新和缓存时间。而强缓存虽然简单，但无法保证数据的实时性。



#### **浏览器的垃圾回收机制**

垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存，但闭包在函数执行结束后不会被回收。

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

“进入环境” - 离开环境 回收

跟踪记录每个值被引用的次数 ，次数为0 ，回收

#### **哪些情况会导致内存泄漏**

由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中
